<?php
use \Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\group\Entity\Group;
use Drupal\scitalk_base\ScitalkServices\ReferenceIDGeneratorInterface;

/**
 * Implements hook_theme().
 */
function scitalk_base_theme($existing, $type, $theme, $path) {
  return [
    'scitalk_social_media_share_block' => [
      'variables' => ['title' => ''],
      'template' => 'block--scitalk-social-media-share'
    ],
    'scitalk_citations_block' => [
      'variables' => [
        'title' => '',
        'bibtex_title' => '',
        'talk_number' => '',
        'talk_date' => '',
        'talk_date_formatted' => '',
        'speakers' => [],
        'doi' => '',
        'url' => '',
        'language' => '',
        'site_name' => '',
        'year' => '',
        'keywords' => '',
        'publisher' => '',
        'repository' => ''
      ],
      'template' => 'block--scitalk-citations'
    ],
  ];
}

/**
 * Implements hook_entity_base_field_info
 * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
 * @return NULL[]
 */
function scitalk_base_entity_base_field_info(\Drupal\Core\Entity\EntityTypeInterface $entity_type) {
  if ($entity_type->id() == 'node') {
  }
  
  if ($entity_type->id() == 'taxonomy_term') {
  }
}

/**
 * Implements hook_entity_bundle_field_info
 */
function scitalk_base_entity_bundle_field_info(\Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle, array $base_field_definitions) {
  //create computed field to display the number of talks under a Collection or Series
  if ($entity_type->id() == 'node' && in_array($bundle, ['collection'])) {
    $fields['scitalk_number_of_talks'] = BaseFieldDefinition::create('integer')
    ->setLabel(t('Number of Talks'))
    ->setDescription(t('Number of Talks in a Collection or Series.'))
    ->setDefaultValue(0)
    ->setInitialValue(0)
    ->setComputed(TRUE)
    ->setClass('\Drupal\scitalk_base\Plugin\Field\SciTalkEntityNumberOfTalksList')
    ->setDisplayConfigurable('view', TRUE)
    ->setDisplayOptions('view', [
      'label' => 'inline',
      'weight' => -1,
      'region' => 'disabled',
      'type' => 'scitalk_number_of_talks_formatter',
    ]);
    
    $fields['scitalk_most_recent_talk'] = BaseFieldDefinition::create('datetime')
    ->setLabel(t('Most recent Talk'))
    ->setDescription(t('Date of the most recent Talks in a Collection or Series.'))
    ->setDefaultValue(NULL)
    ->setInitialValue(NULL)
    ->setComputed(TRUE)
    ->setClass('\Drupal\scitalk_base\Plugin\Field\SciTalkMostRecentTalkList')
    ->setDisplayConfigurable('view', TRUE)
    ->setDisplayOptions('view', [
      'label' => 'inline',
      'weight' => -2,
      'region' => 'disabled',
      'type' => 'scitalk_most_recent_talk_formatter',
    ]);
    
    return $fields;
  }
}

/**
 * Implements hook_entity_bundle_field_info_alter
 */
function scitalk_base_entity_bundle_field_info_alter(&$fields, \Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle) {
  //add Unique constraints for fied field_talk_number in Talks and field_collection_number in taxonomies Series and Collection
  if ($bundle == 'talk') {
    if (isset($fields['field_talk_number'])) {
      // Use the ID as defined in the annotation of the constraint definition
      $fields['field_talk_number']->addConstraint('UniqueTalkNumber', []);
    }
  }
  else if ($bundle == 'collection') {  //Fires for any entity whose bundle is set to 'collection'
    if (isset($fields['field_collection_number'])) {
      $fields['field_collection_number']->addConstraint('UniqueCollectionNumber');
    }
  }
}


/**
 * Implements hook_entity_type_alter().
 */
function scitalk_base_entity_type_alter(array &$entity_types) {
  //Groups manage Repository security. As a result the group is not a content type 
  //but rather a content entity.  We must add a constraint on the 
  //group entity to ensure the title doesn't breach our max length.
  $entity_types['group']->addConstraint('RepositoryShortNameMaxLength', []);
}


/**
 * Implements hook_ENTITY_TYPE_presave()
 */
function scitalk_base_node_presave(\Drupal\Core\Entity\EntityInterface $entity) {
  if ($entity->getType() == 'talk') {
    //when creating a new Talk, if there is no talk number in the entity yet, then create one and assign it to the field.
    if ($entity->isNew()) {
      
      
      // if (_scitalk_base_use_doi($entity)) {
      //   //when creating a new Talk, create a Draft DOI
      //   $doi = \Drupal::service('scitalk_base.datacite_dois');
      //   $doi_id = $doi->create($entity);
      
      //   if (empty($entity->get('field_talk_doi')->value)) {
      //     $entity->set('field_talk_doi', $doi_id);
      //   }
      // }
    }
    else {
      if (_scitalk_base_use_doi($entity)) {
        //update DOI
        $doi = \Drupal::service('scitalk_base.datacite_dois');
        $doi_id = $doi->update($entity);
        
        if (empty($entity->get('field_talk_doi')->value)) {
          $entity->set('field_talk_doi', $doi_id);
        }
      }
    }
  }
  
  
  
  
  //For both the collection and talk, if this content is already grouped, then
  //add the entity reference to the group in the source repository ER field.
  //If this entity does not have a group, determine your group and fill the field
  //as the entity will be grouped.
  if ($entity->getType() == 'collection' || $entity->getType() == 'talk') {
    $user = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());
    $groups = [];
    $groupMembershipService = \Drupal::service('group.membership_loader');
    $userGroups = $groupMembershipService->loadByUser($user);
    foreach ($userGroups as $grp) {
      $groups[] = $grp->getGroup();
      break;  //we just need the first one
    }
    
    if(count($groups)) { //if we have groups, using the first one only, use the ID for the ER
      $groupID = $groups[0]->id();
      if($entity->getType() == 'talk') {
        $entity->set('field_talk_source_repository', $groupID);
      }
      else {
        $entity->set('field_collection_source_repo', $groupID);
      }
    }
    
    //collections have collection_number so create a collection number for them if none exists
    if ($entity->getType() == 'collection') {
      if ($entity->isNew()) {
        $input_coll_number = $entity->get('field_collection_number')->value ?? '';
        if (empty($input_coll_number)) {
          $idGenerator = \Drupal::service('scitalk_base.reference_id_generator');
          $collection_number = $idGenerator->generateReferenceId($entity);
          $entity->set('field_collection_number', $collection_number);
        }
      }
    }
    
    
    if ($entity->getType() == 'talk') {
      //when creating a new Talk, if there is no talk number in the entity yet, then create one and assign it to the field.
      if ($entity->isNew()) {
        $entity_talk_number = $entity->field_talk_number->value ?? '';
        if (empty($entity_talk_number)) {
          $idGenerator = \Drupal::service('scitalk_base.reference_id_generator');
  
          //call service to generate talk id:
          $talk_num = $idGenerator->generateReferenceId($entity);
          //add it to the entity:
          $entity->set('field_talk_number', $talk_num);
        }
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert()
 */
function scitalk_base_node_insert(Drupal\Core\Entity\EntityInterface $entity) {
  /*
   * Upon insertion of a talk or collection, we bind the content
   * to the first group the user doing the saving has access to.
   */
  if ($entity->getType() == 'talk' || $entity->getType() == 'collection') {
    $user = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());
    $groups = [];
    $groupMembershipService = \Drupal::service('group.membership_loader');
    $userGroups = $groupMembershipService->loadByUser($user);
    foreach ($userGroups as $grp) {
      $groups[] = $grp->getGroup();
      break;  //we just need the first one
    }

    if(count($groups)) { //if we have groups, using the first one only, group this entity
      $group = Group::load($groups[0]->id());
      $pluginId = 'group_node:' . $entity->getType();
      $group->addContent($entity, $pluginId);
    }
  }

  
  
  if (_scitalk_base_use_doi($entity)) {
    //when creating a new Talk, create a Draft DOI
    $doi = \Drupal::service('scitalk_base.datacite_dois');
    $doi_id = $doi->create($entity);
    
    if (empty($entity->get('field_talk_doi')->value)) {
      $entity->set('field_talk_doi', $doi_id);
      $entity->save();
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave()
 */
function scitalk_base_taxonomy_term_presave(Drupal\taxonomy\Entity\Term $taxonomy) {
  
}

/**
 * Implements hook_form_alter().
 */
function scitalk_base_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  
  
  /*
   * The original form alter used here was to force a source repository.
   * The source repository is now a Drupal Group which manages the linkages
   * to content FROM the group to the content itself.
   * 
   * In the initial save of content we attach the content to a source repository group
   * if the user is a part of one.
   */
  
  
  //detect if this is a node form, taxonomy collection or series
//               if( $form_id == 'node_talk_form') {
//                     //detect if there is a single Source (Source Repository content type)
//                     //if so, set it to the value in the form.
                    
//                     $query = \Drupal::entityQuery('node');
//                     $query->condition('status', 1);
//                     $query->condition('type', 'source_repository');
//                     $entity_ids = $query->execute();
                    
//                     if(count($entity_ids) === 1) {
//                       //only 1 repository, fill it in.
//                       $singleSource = \Drupal\node\Entity\Node::load(current($entity_ids));
//                       if($singleSource) {
//                         if($form_id == 'node_talk_form') {
//                           $form['field_talk_source']['widget'][0]['target_id']['#default_value'] = $singleSource;
//                         }
//                         elseif($form_id == 'taxonomy_term_collection_form') {
//                           $form['field_collection_source']['widget'][0]['target_id']['#default_value'] = $singleSource;
//                         }
//                         elseif($form_id == 'taxonomy_term_series_form') {
//                           $form['field_series_source']['widget'][0]['target_id']['#default_value'] = $singleSource;
//                         }
//                       }
//                     }
//                   }
}

//check whether to create/update DOIs for this type of entity Talk
function _scitalk_base_use_doi(\Drupal\Core\Entity\EntityInterface $entity) {
  $config = \Drupal::config('scitalk_base.settings');
  $doi_enabled = $config->get('use_doi');
  
  //if DOI config is not enabled then no
  if (!$doi_enabled) return false;
  
  //if DOI config is on then check if this Talk type is configured to create DOIs
  $create_doi_for_this_talk_type = false;
  $talk_type = $entity->field_talk_type->target_id ?? 0;
  if (!empty($talk_type)) {
    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($talk_type);
    $create_doi_for_this_talk_type = $term->field_create_doi->value ?? false;
  }
  
  return $create_doi_for_this_talk_type;
}